<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.co/gsap@3/dist/gsap.min.js"></script>
    <script src="https://unpkg.com/gsap@3/dist/Draggable.min.js"></script>
    <script src="https://assets.codepen.io/16327/InertiaPlugin.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@500;700&display=swap');

        body {
            font-family: 'Manrope', sans-serif;
        }



        .piece:not(.draggable) {
            cursor: default !important;
        }

        .relative {
            width: 80%;
            margin: 0 auto;
        }

        .piece {
            padding: 3px;
            position: absolute;
        }
    </style>
</head>

<body>



    <section class="relative">
        <button type="button" id="reset" disabled
            class="grow px-5 py-2 md:py-3 text-center lg:text-lg tracking-wide rounded-full text-white bg-stone-800 hover:bg-stone-700 active:bg-stone-900 disabled:bg-stone-400 disabled:opacity-50 transition">Start
            again</button>

        <div id="puzzle" class="">
            <div class="piece empty absolute" data-position-left="1" data-position-top="1"></div>
            <div class="piece" data-position-left="2" data-position-top="1">
                <img src="/asset/img/insta1.jpg" alt="">
            </div>
            <div class="piece" data-position-left="3" data-position-top="1">
                <img src="/asset/img/insta1.jpg" alt="">
            </div>
            <div class="piece" data-position-left="1" data-position-top="2">
                <img src="/asset/img/insta1.jpg" alt="">
            </div>
            <div class="piece" data-position-left="2" data-position-top="2">
                <img src="/asset/img/insta1.jpg" alt="">
            </div>
            <div class="piece" data-position-left="3" data-position-top="2">
                <img src="/asset/img/insta1.jpg" alt="">
            </div>
            <div class="piece" data-position-left="1" data-position-top="3">
                <img src="/asset/img/insta1.jpg" alt="">
            </div>
            <div class="piece" data-position-left="2" data-position-top="3">
                <img src="/asset/img/insta1.jpg" alt="">
            </div>
            <div class="piece" data-position-left="3" data-position-top="3">
                <img src="/asset/img/insta1.jpg" alt="">
            </div>
        </div>


    </section>



    <script>
        const puzzle = document.getElementById('puzzle'),
            pieces = puzzle.getElementsByClassName('piece'),
            gridColumns = 3,
            gridRows = 3,
            gridWidth = Math.round(puzzle.offsetWidth / gridColumns),
            gridHeight = gridWidth,
            overlapThreshold = '20%'
        buttonReset = document.getElementById('reset');

        const swapOverlap = (el) => {
            for (let i = 0; i < pieces.length; i++) {
                const piece = pieces[i];
                if (el.hitTest(piece, overlapThreshold)) {
                    if (piece.classList.contains('empty')) {
                        TweenLite.to(
                            piece,
                            0.2,
                            {
                                x: el.startX,
                                y: el.startY,
                            }
                        );
                        buttonReset.disabled = false;
                    } else {
                        TweenLite.to(
                            el.target,
                            0.2,
                            {
                                x: el.startX,
                                y: el.startY,
                            }
                        );
                    }
                }
            }
        };

        gsap.set(
            puzzle,
            {
                width: gridColumns * gridWidth,
                height: gridRows * gridHeight,
            }
        );

        for (let i = 0; i < pieces.length; i++) {
            const piece = pieces[i];
            const { positionLeft, positionTop } = pieces[i].dataset;

            gsap.set(
                piece,
                {
                    width: gridWidth,
                    height: gridHeight,
                    x: gridWidth * (positionLeft - 1),
                    y: gridWidth * (positionTop - 1),
                }
            );

            buttonReset.addEventListener('click', (e) => {
                buttonReset.disabled = true;
                TweenLite.to(
                    piece,
                    0.2,
                    {
                        x: gridWidth * (positionLeft - 1),
                        y: gridWidth * (positionTop - 1),
                    }
                );
                setTimeout(() => {
                    draggablePieces();
                }, 300);
                e.preventDefault();
            });
        };

        const draggablePieces = () => {
            const offsetEmpty = puzzle.querySelector('.empty').getBoundingClientRect();

            for (let i = 0; i < pieces.length; i++) {
                const piece = pieces[i];
                const offsetPiece = piece.getBoundingClientRect();

                if (!piece.classList.contains('empty')) {
                    if (
                        Math.abs(Math.floor(offsetPiece.left) - Math.floor(offsetEmpty.right)) <= 10 && offsetPiece.top === offsetEmpty.top ||
                        Math.abs(Math.floor(offsetPiece.right) - Math.floor(offsetEmpty.left)) <= 10 && offsetPiece.top === offsetEmpty.top ||
                        Math.abs(Math.floor(offsetPiece.top) - Math.floor(offsetEmpty.bottom)) <= 10 && offsetPiece.left === offsetEmpty.left ||
                        Math.abs(Math.floor(offsetPiece.bottom) - Math.floor(offsetEmpty.top)) <= 10 && offsetPiece.left === offsetEmpty.left
                    ) {
                        piece.classList.add('draggable');
                    } else {
                        piece.classList.remove('draggable');
                    }
                }
            }
        }
        draggablePieces();

        Draggable.create(
            pieces,
            {
                bounds: puzzle,
                dragResistance: 1,
                edgeResistance: 0.9,
                throwResistance: 9999999,
                maxDuration: 0.2,
                minDuration: 0.1,
                overshootTolerance: 0,
                type: 'x,y',
                inertia: true,
                snap: {
                    x: function (endValue) {
                        return Math.round(endValue / gridWidth) * gridWidth;
                    },
                    y: function (endValue) {
                        return Math.round(endValue / gridHeight) * gridHeight;
                    }
                },
                onPressInit: function () {
                    this.startX = gsap.getProperty(this, 'x');
                    this.startY = gsap.getProperty(this, 'y');
                    if (this.target.classList.contains('draggable')) {
                        this.dragResistance = 0;
                    } else {
                        this.dragResistance = 1;
                    }
                },
                onThrowComplete: function () {
                    swapOverlap(this);
                    setTimeout(() => {
                        draggablePieces();
                    }, 300);
                },
            }
        );
    </script>
</body>

</html>